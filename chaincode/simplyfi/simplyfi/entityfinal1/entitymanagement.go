package main

import (
	"encoding/json"
	"fmt"
	"strconv"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	id "github.com/hyperledger/fabric/core/chaincode/shim/ext/cid"
	"github.com/hyperledger/fabric/protos/peer"
)

var _entityLogger = shim.NewLogger("EntityManager")

const _CreateEvent = "CREATE_ENTITY"
const _ModifyEvent = "MODIFY_ENTITY"

//Entity structure defines the ledger record for any entity
type Entity struct {
	ObjType     string `json:"obj"`   //DocType  -- search key
	EntityID    string `json:"id"`    //EntityID -- Key field - autogenerated in backend
	EntityType  string `json:"etype"` // GOVT OR PRIVATE OR SEBI 
	POI         string `json:"poi"`   // TAN OR PAN NO OF ENTITY Mandatory for Private
	EntityName  string `json:"name"`  //EntityName -- search Key
	EntityClassification string `json:"eclass"` //PE or TM
	ServiceProvider string `json:"svcprv"` //AccessProvidedID
	Status          string `json:"sts"`    //Status
	ApprovedOn      string `json:"appon"`  
	Creator         string `json:"crtr"` //CreatedBy
	UpdateTs        string `json:"uts"`  //UpdatedTs - autogenerated in backend
	CreateTs        string `json:"cts"`  //CreatedTs - autogenerated in backend
	UpdatedBy       string `json:"uby"`  //UpdatedBy
	BlackListed		string `json:"blist"` //blacklisted
}

//EntityManager manages entity transactions
type EntityManager struct {
}

var orgType = map[string]bool{
	"P": true,
	"G": true,
	"S": true,
	"U": true,
	"O": true,
}

var entityStatus = map[string]bool{
	"A": true,
	"I": true,
}

var serviceProvider = map[string]bool{
	"AI": true,
	"VO": true,
	"ID": true,
	"BL": true,
	"ML": true,
	"QL": true,
	"TA": true,
	"JI": true,
	"VI": true,
}
var validCategotyMap = map[string]bool{
	"PE": true,
	"TM": true,
}

func validEnumEntry(input string, enumMap map[string]bool) bool {
	if _, isEntryExists := enumMap[input]; !isEntryExists {
		return false
	}
	return true
}

//CheckValidityForStatus checks for  validity of entity for status trxn
func CheckValidityForStatus(searchEntityID, newStatus, newUpdatedTS string) (bool, string) {
	if searchEntityID == "" {
		return false, "Entity Id should be present there"
	}
	if newStatus == "" {
		return false, "Status should be present there"
	}
	if newUpdatedTS == "" {
		return false, "Update timeStamp should be present there"
	}
	return true, ""
}

//IsValidEntityIDPresent checks for  validity of entity for modify trxn
func IsValidEntityIDPresent(e Entity) (bool, string) {

	if len(e.EntityID) == 0 {
		return false, "Entity Id should be present there"
	}
	if len(e.EntityName) == 0 {
		return false, "Entity name is mandatory"
	}

	if len(e.UpdateTs) == 0 {
		return false, "UpdatedTS is mandatory"
	}

	if !validEnumEntry(e.EntityType, orgType) {
		return false, "Enter value P, G, S, U or O"
	}

	if e.EntityType == "P" {
		if len(e.POI) == 0 {
			return false, "PAN No is required"
		}
	}

	if !validEnumEntry(e.Status, entityStatus) {
		return false, "Enter either A, I or B"
	}

	if !validEnumEntry(e.ServiceProvider, serviceProvider) {
		return false, "Service Provider: Either AI, VO, ID, BL, ML, QL, TA, JI or VI"
	}

	if !validEnumEntry(e.EntityClassification, validCategotyMap) {
		return false, "Must provide either PE or TM"
	}
	return true, ""
}

//IsValid checks if the entity fields are valid of not
func IsValid(e Entity) (bool, string) {

	if len(e.EntityName) == 0 {
		return false, "Entity name is mandatory"
	}
	if !validEnumEntry(e.EntityType, orgType) {
		return false, "Enter value P, G, S, U or O"
	}

	if e.EntityType == "P" {
		if len(e.POI) == 0 {
			return false, "PAN No is required"
		}
	}

	if !validEnumEntry(e.Status, entityStatus) {
		return false, "Enter either A, I or B"
	}

	if !validEnumEntry(e.ServiceProvider, serviceProvider) {
		return false, "Invalid ServiceProvider"
	}

	if !validEnumEntry(e.EntityClassification, validCategotyMap) {
		return false, "Must provide either PE or TM"
	}

	return true, ""
}

//SearchEntity searchs for entity based on the input parameters
func (em *EntityManager) SearchEntity(stub shim.ChaincodeStubInterface) peer.Response {
	var response peer.Response
	searchCriteria := make(map[string]string)
	_, args := stub.GetFunctionAndParameters()
	if len(args) < 1 {
		return shim.Error("Invalid number of arguments provided for transaction")
	}
	err := json.Unmarshal([]byte(args[0]), &searchCriteria)
	if err != nil {
		return shim.Error("Invalid json provided as input")
	}
	searchType, isOk := searchCriteria["typ"]
	if !isOk {
		return shim.Error("Search type not provided")
	}
	switch searchType {
	case "name":
		entitySearchCriteria := `{
			"obj":"Entity"	,
			"name":"%s"
		}`
		entityName := searchCriteria[searchType]
		entities := em.retriveEntityRecords(stub, fmt.Sprintf(entitySearchCriteria, entityName), "entitySearchByName")
		recordsJSON, _ := json.Marshal(entities)
		response = shim.Success(recordsJSON)
	case "id":
		entitySearchCriteria := `{
			"obj":"Entity"	,
			"id":"%s"
		}`
		entityID := searchCriteria[searchType]
		entities := em.retriveEntityRecords(stub, fmt.Sprintf(entitySearchCriteria, entityID), "entitySearchByID")
		recordsJSON, _ := json.Marshal(entities)
		response = shim.Success(recordsJSON)
	case "svcprv":
		entitySearchCriteria := `{
			"obj":"Entity"	,
			"svcprv":"%s"
		}`
		entityID := searchCriteria[searchType]
		entities := em.retriveEntityRecords(stub, fmt.Sprintf(entitySearchCriteria, entityID), "entitySearchByAP")
		recordsJSON, _ := json.Marshal(entities)
		response = shim.Success(recordsJSON)
	case "poi":
		entitySearchCriteria := `{
			"obj":"Entity"	,
			"poi":"%s"
		}`
		entityID := searchCriteria[searchType]
		entities := em.retriveEntityRecords(stub, fmt.Sprintf(entitySearchCriteria, entityID), "entitySearchByPoi")
		recordsJSON, _ := json.Marshal(entities)
		response = shim.Success(recordsJSON)
	default:
		response = shim.Error("Unsupported search type provided " + searchType)
	}
	return response
}

//CreateEntity creates an entity in the ledger
func (em *EntityManager) CreateEntity(stub shim.ChaincodeStubInterface) peer.Response {
	_, args := stub.GetFunctionAndParameters()
	if len(args) < 1 {
		return shim.Error("Invalid number of arguments provided for transaction")
	}
	var entityToSave Entity
	err := json.Unmarshal([]byte(args[0]), &entityToSave)
	if err != nil {
		return shim.Error("Invalid json provided as input")
	}
	//Second Check if the entity id is existing or not
	if recordBytes, _ := stub.GetState(entityToSave.EntityID); len(recordBytes) > 0 {
		return shim.Error("Entityid already registered. Provide an unique entity id")
	}
	entityToSave.ObjType = "Entity"
	_, creator := em.getInvokerIdentity(stub)
	entityToSave.Creator = creator
	entityToSave.UpdatedBy = creator
	entityToSave.BlackListed= "N"
	//Save the entry
	entityJSON, _ := json.Marshal(entityToSave)
	if isValid, errMsg := IsValid(entityToSave); !isValid {
		return shim.Error(errMsg)
	}
	_entityLogger.Info("entityToSave.EntityID----------", entityToSave.EntityID)
	err = stub.PutState(entityToSave.EntityID, entityJSON)

	if err != nil {
		return shim.Error("Unable to save with entity id " + entityToSave.EntityID)
	}
	retErr := stub.SetEvent(_CreateEvent, entityJSON)

	if retErr != nil {
		_entityLogger.Errorf("Event not generated for event : CREATEENTITY")
		return shim.Error("{\"error\":\"Unable to port number.\"}")
	}
	resultData := map[string]interface{}{
		"trxnID":   stub.GetTxID(),
		"entityID": entityToSave.EntityID,
		"message":  "Save successful",
		"entity":   entityToSave,
	}
	respJSON, _ := json.Marshal(resultData)
	return shim.Success(respJSON)
}

//ModifyEntity modifies an existing entiry
func (em *EntityManager) ModifyEntity(stub shim.ChaincodeStubInterface) peer.Response {

	_, args := stub.GetFunctionAndParameters()
	if len(args) < 1 {
		return shim.Error("Invalid arguments provided")
	}

	var modifiedEntity Entity
	errEntity := json.Unmarshal([]byte(args[0]), &modifiedEntity)
	if errEntity != nil {
		return shim.Error(errEntity.Error())
	}

	entityRecords, err := stub.GetState(modifiedEntity.EntityID)
	if err != nil {
		return shim.Error(err.Error())
	}
	var existingEntity Entity
	errExistingEntity := json.Unmarshal([]byte(entityRecords), &existingEntity)
	if errExistingEntity != nil {
		return shim.Error(errExistingEntity.Error())
	}

	modifiedEntity.ObjType = "Entity"

	_, creatorUpdateBy := em.getInvokerIdentity(stub)

	modifiedEntity.UpdatedBy = creatorUpdateBy

	if isValid, errMsg := IsValidEntityIDPresent(modifiedEntity); !isValid {
		return shim.Error(errMsg)
	}

	marshalEntiryJSON, _ := json.Marshal(modifiedEntity)
	finalErr := stub.PutState(modifiedEntity.EntityID, marshalEntiryJSON)

	if finalErr != nil {
		return shim.Error("Unable to save with entity id " + modifiedEntity.EntityID)
	}
	retErr := stub.SetEvent(_ModifyEvent, marshalEntiryJSON)

	if retErr != nil {
		_entityLogger.Errorf("Event not generated for event : MODIFY_ENTITY")
		return shim.Error("{\"error\":\"Unable to port number.\"}")
	}
	resultData := map[string]interface{}{
		"trxnID":   stub.GetTxID(),
		"entityID": modifiedEntity.EntityID,
		"message":  "Save successful",
		"entity":   modifiedEntity,
	}
	respJSON, _ := json.Marshal(resultData)
	return shim.Success(respJSON)
}

func (em *EntityManager) retriveEntityRecords(stub shim.ChaincodeStubInterface, criteria string, indexs ...string) []Entity {
	var finalSelector string
	records := make([]Entity, 0)

	if len(indexs) == 0 {
		finalSelector = fmt.Sprintf("{\"selector\":%s }", criteria)

	} else {
		finalSelector = fmt.Sprintf("{\"selector\":%s , \"use_index\" :\"%s\" }", criteria, indexs[0])
	}

	_entityLogger.Infof("Query Selector : %s", finalSelector)
	resultsIterator, _ := stub.GetQueryResult(finalSelector)
	for resultsIterator.HasNext() {
		record := Entity{}
		recordBytes, _ := resultsIterator.Next()
		err := json.Unmarshal(recordBytes.Value, &record)
		if err != nil {
			_entityLogger.Infof("Unable to unmarshal entity retived:: %v", err)
		}
		records = append(records, record)
	}
	return records
}

// GetHistoryByKey queries the ledger using key.
// It retrieve all the changes to the value happened over time.
func (em *EntityManager) GetHistoryByKey(stub shim.ChaincodeStubInterface) peer.Response {
	_entityLogger.Debug("GetHistoryByKey called.")

	_, args := stub.GetFunctionAndParameters()

	// Essential check to verify number of arguments
	if len(args) != 1 {
		_entityLogger.Error("Incorrect number of arguments passed in GetHistoryByKey.")
		resp := shim.Error("Incorrect number of arguments. Expecting 1 arguments: " + strconv.Itoa(len(args)) + " given.")
		return resp
	}

	key := args[0]
	resultsIterator, err := stub.GetHistoryForKey(key)

	if err != nil {
		_entityLogger.Error("Error occured while calling GetHistoryForKey(): ", err)
		return shim.Error("Error occured while calling GetHistoryForKey: " + err.Error())
	}
	defer resultsIterator.Close()

	// buffer is a JSON array containing historic values for the event
	historicResponse := make([]map[string]interface{}, 0)
	for resultsIterator.HasNext() {
		response, err := resultsIterator.Next()
		if err != nil {
			_entityLogger.Error("Error occured while calling resultsIterator.Next(): ", err)
			return shim.Error("Error occured while calling GetHistoryByKey (resultsIterator): " + err.Error())
		}
		value := make(map[string]interface{})
		json.Unmarshal(response.Value, &value)
		historicResponse = append(historicResponse, map[string]interface{}{"txId": response.TxId, "value": value})

	}

	respJSON, _ := json.Marshal(historicResponse)
	return shim.Success(respJSON)
}

//UpdateEntityStatus updates the status of the entity ledger entry
func (em *EntityManager) UpdateEntityStatus(stub shim.ChaincodeStubInterface) peer.Response {
	_entityLogger.Info("within UpdateEntityStatus")
	_, args := stub.GetFunctionAndParameters()

	if len(args) < 3 {
		return shim.Error("Invalid No of arguments provided")
	}

	searchEntityID := args[0]
	newStatus := args[1]
	newUpdatedTS := args[2]

	if isValid, errMsg := CheckValidityForStatus(searchEntityID, newStatus, newUpdatedTS); !isValid {
		return shim.Error(errMsg)
	}

	entityRecords, _ := stub.GetState(searchEntityID)
	var updatedStatusEntity Entity
	err := json.Unmarshal(entityRecords, &updatedStatusEntity)
	if err != nil {
		return shim.Error("Error when unmarshaling the data")
	}

	updatedStatusEntity.Status = newStatus
	updatedStatusEntity.UpdateTs = newUpdatedTS
	_, updatedBy := em.getInvokerIdentity(stub)
	updatedStatusEntity.UpdatedBy = updatedBy

	marshalEntiryJSON, _ := json.Marshal(updatedStatusEntity)

	finalErr := stub.PutState(updatedStatusEntity.EntityID, marshalEntiryJSON)

	if finalErr != nil {
		return shim.Error("Unable to save with entity id " + updatedStatusEntity.EntityID)
	}
	retErr := stub.SetEvent(_ModifyEvent, marshalEntiryJSON)

	if retErr != nil {
		_entityLogger.Errorf("Event not generated for event : MODIFY_ENTITY")
		return shim.Error("{\"error\":\"Unable to update entity status.\"}")
	}
	resultData := map[string]interface{}{
		"trxnID":   stub.GetTxID(),
		"entityID": updatedStatusEntity.EntityID,
		"message":  "Save successful",
		"entity":   updatedStatusEntity,
	}
	respJSON, _ := json.Marshal(resultData)
	return shim.Success(respJSON)

}

//Returns the complete identity in the format
//Certitificate issuer orgs's domain name
//Returns string Unkown if not able parse the invoker certificate
func (em *EntityManager) getInvokerIdentity(stub shim.ChaincodeStubInterface) (bool, string) {
	//Following id comes in the format X509::<Subject>::<Issuer>>
	enCert, err := id.GetX509Certificate(stub)
	if err != nil {
		return false, "Unknown."
	}

	issuersOrgs := enCert.Issuer.Organization
	if len(issuersOrgs) == 0 {
		return false, "Unknown.."
	}
	return true, fmt.Sprintf("%s", issuersOrgs[0])

}
