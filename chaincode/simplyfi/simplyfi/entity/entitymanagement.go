package main

import (
	"encoding/json"
	"fmt"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	id "github.com/hyperledger/fabric/core/chaincode/shim/ext/cid"
	"github.com/hyperledger/fabric/protos/peer"
)

var _entityLogger = shim.NewLogger("EntityManager")

const _CreateEvent = "CREATE_ENTITY"
const _ModifyEvent = "MODIFY_ENTITY"

//Entity structure defines the ledger record for any entity
type Entity struct {
	ObjType     string `json:"obj"`   //DocType  -- search key
	RegReqestID string `json:"reqid"` //
	EntityID    string `json:"id"`    //EntityID -- Key field - autogenerated in backend
	EntityType  string `json:"etype"` // GOVT OR PRIVATE OR SEBI OR KNOWN BRAND
	POI         string `json:"poi"`   // TAN OR PAN NO OF ENTITY Mandatory for Private
	EntityName  string `json:"name"`  //EntityName -- search Key
	//ParentID             string   `json:"pid"`
	//EntityCreditFlag     []string `json:"ecr"`
	EntityClassification string `json:"eclass"` //PE or TM
	//TmFunctions          []string `json:"tfunc"`
	ServiceProvider string `json:"svcprv"` //AccessProvidedID
	Status          string `json:"sts"`    //Status
	ApprovedOn      string `json:"appon"`
	ApprovedBy      string `json:"appby"`
	Creator         string `json:"crtr"` //CreatedBy
	UpdateTs        string `json:"uts"`  //UpdatedTs - autogenerated in backend
	CreateTs        string `json:"cts"`  //CreatedTs - autogenerated in backend
	UpdatedBy       string `json:"uby"`  //UpdatedBy

}

//EntityManager manages entity transactions
type EntityManager struct {
}

var orgType = map[string]bool{
	"P": true,
	"G": true,
	"S": true,
	"K": true,
	"U": true,
	"O": true,
}

var entityStatus = map[string]bool{
	"A": true,
	"I": true,
	"B": true,
}

var serviceProvider = map[string]bool{
	"AI": true,
	"VO": true,
	"ID": true,
	"BL": true,
	"ML": true,
	"QL": true,
	"TA": true,
	"JI": true,
	"VI": true,
}
var validCategoryMap = map[string]bool{
	"PE": true,
	"TM": true,
}

func validEnumEntry(input string, enumMap map[string]bool) bool {
	if _, isEntryExists := enumMap[input]; !isEntryExists {
		return false
	}
	return true
}

//IsValidEntityIDPresent checks for  validity of entity for modify trxn
func IsValidEntityIDPresent(e Entity) (bool, string) {

	if len(e.EntityID) == 0 {
		return false, "Entity Id should be present there"
	}
	if len(e.EntityName) == 0 {
		return false, "Entity name is mandatory"
	}

	if len(e.UpdatedBy) == 0 {
		return false, "Updated By is mandatory"
	}

	if !validEnumEntry(e.EntityType, orgType) {
		return false, "Enter value P or G or S or K or U or O"
	}

	if e.EntityType == "P" {
		if len(e.POI) == 0 {
			return false, "PAN No is required"
		}
	}

	if !validEnumEntry(e.Status, entityStatus) {
		return false, "Enter either A, I or B"
	}

	if !validEnumEntry(e.ServiceProvider, serviceProvider) {
		return false, "Invalid ServiceProvider"
	}

	if !validEnumEntry(e.EntityClassification, validCategoryMap) {
		return false, "Must provide either PE or TM"
	}
	return true, ""
}

//IsValid checks if the entity fields are valid of not
func IsValid(e Entity) (bool, string) {

	if len(e.EntityName) == 0 {
		return false, "Entity name is mandatory"
	}
	if !validEnumEntry(e.EntityType, orgType) {
		return false, "Enter value P or G or S or K or U or O"
	}

	if len(e.ApprovedBy) == 0 {
		return false, "Approved By is mandatory"
	}

	if e.EntityType == "P" {
		if len(e.POI) == 0 {
			return false, "PAN No is required"
		}
	}
	if !validEnumEntry(e.Status, entityStatus) {
		return false, "Enter either A, I or B"
	}

	if !validEnumEntry(e.ServiceProvider, serviceProvider) {
		return false, "Invalid ServiceProvider"
	}

	if !validEnumEntry(e.EntityClassification, validCategoryMap) {
		return false, "Must provide either PE or TM"
	}

	return true, ""
}

//SearchEntity searchs for entity based on the input parameters
func (em *EntityManager) SearchEntity(stub shim.ChaincodeStubInterface) peer.Response {
	var response peer.Response
	searchCriteria := make(map[string]string)
	_, args := stub.GetFunctionAndParameters()
	if len(args) < 1 {
		return shim.Error("Invalid number of arguments provided for transaction")
	}
	err := json.Unmarshal([]byte(args[0]), &searchCriteria)
	if err != nil {
		return shim.Error("Invalid json provided as input")
	}
	searchType, isOk := searchCriteria["typ"]
	if !isOk {
		return shim.Error("Search type not provided")
	}
	switch searchType {
	case "name":
		entitySearchCriteria := `{
			"obj":"Entity"	,
			"name":"%s"
		}`
		entityName := searchCriteria[searchType]
		entities := em.retriveEntityRecords(stub, fmt.Sprintf(entitySearchCriteria, entityName), "entitySearchByName")
		recordsJSON, _ := json.Marshal(entities)
		response = shim.Success(recordsJSON)
	case "id":
		entitySearchCriteria := `{
			"obj":"Entity"	,
			"id":"%s"
		}`
		entityID := searchCriteria[searchType]
		entities := em.retriveEntityRecords(stub, fmt.Sprintf(entitySearchCriteria, entityID), "entitySearchByID")
		recordsJSON, _ := json.Marshal(entities)
		response = shim.Success(recordsJSON)
	case "svcprv":
		entitySearchCriteria := `{
			"obj":"Entity"	,
			"svcprv":"%s"
		}`
		entityID := searchCriteria[searchType]
		entities := em.retriveEntityRecords(stub, fmt.Sprintf(entitySearchCriteria, entityID), "entitySearchByAP")
		recordsJSON, _ := json.Marshal(entities)
		response = shim.Success(recordsJSON)
	case "poi":
		entitySearchCriteria := `{
			"obj":"Entity"	,
			"poi":"%s"
		}`
		entityID := searchCriteria[searchType]
		entities := em.retriveEntityRecords(stub, fmt.Sprintf(entitySearchCriteria, entityID), "entitySearchByPoi")
		recordsJSON, _ := json.Marshal(entities)
		response = shim.Success(recordsJSON)
	default:
		response = shim.Error("Unsupported search type provided " + searchType)
	}
	return response
}

//CreateEntity creates an entity in the ledger
func (em *EntityManager) CreateEntity(stub shim.ChaincodeStubInterface) peer.Response {
	_, args := stub.GetFunctionAndParameters()
	if len(args) < 1 {
		return shim.Error("Invalid number of arguments provided for transaction")
	}
	var entityToSave Entity
	err := json.Unmarshal([]byte(args[0]), &entityToSave)
	if err != nil {
		return shim.Error("Invalid json provided as input")
	}

	//Second Check if the entity id is existing or not
	if recordBytes, _ := stub.GetState(entityToSave.EntityID); len(recordBytes) > 0 {
		return shim.Error("Entityid already registered. Provide an unique entity id")
	}

	entityToSave.ObjType = "Entity"
	_, creator := em.getInvokerIdentity(stub)
	entityToSave.Creator = creator
	entityToSave.UpdatedBy = creator

	//Save the entry
	entityJSON, _ := json.Marshal(entityToSave)
	if isValid, errMsg := IsValid(entityToSave); !isValid {
		return shim.Error(errMsg)
	}
	_entityLogger.Info("entityToSave.EntityID----------", entityToSave.EntityID)
	err = stub.PutState(entityToSave.EntityID, entityJSON)

	if err != nil {
		return shim.Error("Unable to save with entity id " + entityToSave.EntityID)
	}
	retErr := stub.SetEvent(_CreateEvent, entityJSON)

	if retErr != nil {
		_entityLogger.Errorf("Event not generated for event : CREATEENTITY")
		return shim.Error("{\"error\":\"Unable to port number.\"}")
	}
	resultData := map[string]interface{}{
		"trxnID":   stub.GetTxID(),
		"entityID": entityToSave.EntityID,
		"message":  "Save successful",
		"entity":   entityToSave,
	}
	respJSON, _ := json.Marshal(resultData)
	return shim.Success(respJSON)
}

//ModifyEntity modifies an existing entiry
func (em *EntityManager) ModifyEntity(stub shim.ChaincodeStubInterface) peer.Response {

	_, args := stub.GetFunctionAndParameters()
	if len(args) < 1 {
		return shim.Error("Invalid arguments provided")
	}

	var modifiedEntity Entity
	errEntity := json.Unmarshal([]byte(args[0]), &modifiedEntity)
	if errEntity != nil {
		return shim.Error(errEntity.Error())
	}

	entityRecords, err := stub.GetState(modifiedEntity.EntityID)
	if err != nil {
		return shim.Error(err.Error())
	}
	var existingEntity Entity
	errExistingEntity := json.Unmarshal([]byte(entityRecords), &existingEntity)
	if errExistingEntity != nil {
		return shim.Error(errExistingEntity.Error())
	}

	modifiedEntity.ObjType = "Entity"

	_, creatorUpdateBy := em.getInvokerIdentity(stub)

	modifiedEntity.UpdatedBy = creatorUpdateBy

	if isValid, errMsg := IsValidEntityIDPresent(modifiedEntity); !isValid {
		return shim.Error(errMsg)
	}

	marshalEntiryJSON, _ := json.Marshal(modifiedEntity)
	finalErr := stub.PutState(modifiedEntity.EntityID, marshalEntiryJSON)

	if finalErr != nil {
		return shim.Error("Unable to save with entity id " + modifiedEntity.EntityID)
	}
	retErr := stub.SetEvent(_ModifyEvent, marshalEntiryJSON)

	if retErr != nil {
		_entityLogger.Errorf("Event not generated for event : MODIFY_ENTITY")
		return shim.Error("{\"error\":\"Unable to port number.\"}")
	}
	resultData := map[string]interface{}{
		"trxnID":   stub.GetTxID(),
		"entityID": modifiedEntity.EntityID,
		"message":  "Save successful",
		"entity":   modifiedEntity,
	}
	respJSON, _ := json.Marshal(resultData)
	return shim.Success(respJSON)
}

func (em *EntityManager) retriveEntityRecords(stub shim.ChaincodeStubInterface, criteria string, indexs ...string) []Entity {
	var finalSelector string
	records := make([]Entity, 0)

	if len(indexs) == 0 {
		finalSelector = fmt.Sprintf("{\"selector\":%s }", criteria)

	} else {
		finalSelector = fmt.Sprintf("{\"selector\":%s , \"use_index\" :\"%s\" }", criteria, indexs[0])
	}
	_entityLogger.Infof("Query Selector : %s", finalSelector)
	resultsIterator, _ := stub.GetQueryResult(finalSelector)
	for resultsIterator.HasNext() {
		record := Entity{}
		recordBytes, _ := resultsIterator.Next()
		err := json.Unmarshal(recordBytes.Value, &record)
		if err != nil {
			_entityLogger.Infof("Unable to unmarshal entity retived:: %v", err)
		}
		records = append(records, record)
	}
	return records
}

//Returns the complete identity in the format
//Certitificate issuer orgs's domain name
//Returns string Unkown if not able parse the invoker certificate
func (em *EntityManager) getInvokerIdentity(stub shim.ChaincodeStubInterface) (bool, string) {
	//Following id comes in the format X509::<Subject>::<Issuer>>
	enCert, err := id.GetX509Certificate(stub)
	if err != nil {
		return false, "Unknown."
	}

	issuersOrgs := enCert.Issuer.Organization
	if len(issuersOrgs) == 0 {
		return false, "Unknown.."
	}
	return true, fmt.Sprintf("%s", issuersOrgs[0])

}
